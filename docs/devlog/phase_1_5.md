# Phase 1.5: 参数干预与因果验证

**版本:** 1.0
**日期:** 2025-07-15
**状态:** 规划中

## 1. 背景与核心目标

在 Phase 1 中，我们成功开发并验证了 `∫SPS` 扫描仪作为一种高效的“功能拓扑显影仪”。它能告诉我们，在特定任务下，模型参数空间中的哪些区域是“功能密集”的。

然而，`∫SPS` 揭示的是**相关性**，而非**因果性**。我们必须在进入宏大的 Phase 2 (拓扑重构) 之前，插入一个关键的验证阶段，以回答一个根本性问题：

**我们用 `∫SPS` 识别出的“功能模块”，是否真的是模型执行特定计算的、可被直接干预的因果节点？**

本阶段的核心目标，就是通过对模型进行**外科手术式的参数干预**，来验证 `∫SPS` 扫描结果的因果有效性。我们将以模型最基础的**四则运算能力**作为我们的“探针”，试图定位并控制其内部的“算术逻辑单元 (ALU)”。

## 2. 实验设计

整个实验将遵循“定位-干预-验证”的三步走战略。

### 阶段一：算术逻辑单元 (ALU) 的定位

1. **探针数据集构建 (`scripts/preprocessing/create_arithmetic_corpus.py`):**

   - **任务：** 编写一个脚本，生成一个专门化的、只包含简单四则运算问题的 SFT 数据集 (`data/sft/arithmetic_corpus.jsonl`)。
   - **数据格式：** 每个样本都遵循“问题-思考-答案”的格式，例如：

     ```json
     {
       "text": "User: What is 123 + 456?\nAssistant: <think>The user wants to add 123 and 456. 100+400=500, 20+50=70, 3+6=9. So the answer is 579.</think>579"
     }
     ```

   - **要求：** 覆盖加、减、乘、除四种运算，数字范围限定在三位数以内，以确保任务的原子性和可控性。

2. **高通量 `∫SPS` 扫描 (`scripts/batch_scanner.py`):**

   - **任务：** 使用我们升级后的批量扫描器，在 `arithmetic_corpus.jsonl` 数据集上，对 `Qwen/Qwen3-1.7B` 模型进行一次完整的 `∫SPS` 扫描。
   - **输出：** 生成一个 `data/scans/Qwen3-1.7B_arithmetic.mscan` 文件，其中包含模型中每个参数块在该算术任务上的积分协同预测分数。

3. **ALU 候选簇识别 (`notebooks/analyze_arithmetic_scan.ipynb`):**
   - **任务：** 编写一个 Jupyter Notebook，对 `arithmetic.mscan` 文件进行分析。
   - **方法：**
     - 首先，根据 `∫SPS` 分数进行硬剪枝，筛选出排名前 1% 的“精英参数块”。
     - 然后，对这些精英参数块的行为摘要向量，应用 **K-Means 聚类**（或更高级的 TDA 方法），识别出在功能上高度内聚的参数簇。
   - **目标：** 识别出 3-5 个最可疑的“ALU 候选簇”。我们预期，可能会存在分别对应“加法逻辑”、“乘法逻辑”等的不同簇。

### 阶段二：参数干预实验

这是本阶段的核心。我们将编写一个新的实验脚本 `scripts/run_intervention.py`，该脚本能够加载原始模型，并根据指定的“干预方案”对其参数进行实时修改。

1. **干预方案定义:**

   - 脚本将接收一个配置文件（例如 `interventions.yaml`），其中定义了干预的“靶点”（即我们在阶段一识别出的 ALU 候选簇的参数名称列表）和“手段”。

2. **干预手段实现:**
   - **零化烧蚀 (Ablation):**
     - **实现：** 在模型加载后，遍历靶点参数列表，使用 `param.data.zero_()` 将其权重原地置零。
     - **预期效果：** 模型的算术能力应显著下降或完全丧失，回答算术问题时会胡言乱语或给出错误答案。
   - **放大增强 (Amplification):**
     - **实现：** 遍历靶点参数，将其权重乘以一个大于 1 的系数，例如 `param.data.mul_(1.5)`。
     - **预期效果：** 模型在处理非算术任务时，也可能表现出“计算倾向”，例如在回答“法国的首都是什么？”时，可能会莫名其妙地开始计算字符数或进行其他数字联想。
   - **功能移植 (Transplantation) [高级目标]:**
     - **实现：** 这是一个更大胆的实验。我们将尝试把从 Qwen3 中识别出的“加法模块”，移植到一个完全不同的、尺寸相近但算术能力较弱的模型中。
     - **预期效果：** 如果移植成功，目标模型应该会获得或显著增强其加法能力。这将是我们“参数即功能模块”理论的最终极证明。

### 阶段三：定量与定性评估

1. **评估脚本 (`scripts/evaluate_intervention.py`):**
   - **任务：** 编写一个评估脚本，用于自动化地测试经过干预的模型。
   - **定量指标：**
     - **算术准确率：** 在一个独立的算术测试集上，计算模型的准确率。
     - **通用能力损失 (Perplexity)：** 在一个通用的语言模型基准（如 WikiText）上计算困惑度，以衡量我们的干预是否对模型的通用语言能力造成了灾难性破坏。
   - **定性分析：** 脚本将生成一系列在标准 prompt 下的干预前后对比样本，供我们进行人工分析。

## 3. 预期结论与风险

- **预期成功结论：** 我们将证明，`∫SPS` 能够精确定位到与特定认知功能（如算术）相关的、在因果链条上真实有效的参数模块。对这些模块的直接干预，能够产生可预测、可控的行为变化，且这种干预具有高度的“功能特异性”，对模型的其他能力影响较小。
- **潜在风险与失败模式：**
  1. **功能高度分布式：** 算术能力可能并非由少数几个集中的模块实现，而是高度分布在整个网络中。如果是这样，对任何单个簇的干预可能都不会产生显著效果。
  2. **灾难性遗忘：** 我们的干预可能过于粗暴，导致模型整体崩溃（即 Perplexity 急剧上升），使得我们无法判断干预是否具有特异性。
  3. **错误的定位：** `∫SPS` 可能只定位到了功能的“表象”而非“核心”。例如，它可能找到了负责“识别数字”的模块，而非负责“计算关系”的模块。

无论结果如何，Phase 1.5 都将为我们提供关于模型内部机制的、前所未有的宝贵数据，并为我们是否以及如何进入 Phase 2 提供最关键的决策依据。
